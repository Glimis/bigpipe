## bigpipe  

response 返回响应信息,有两种结束的方式

test1
* 返回消息长度,协议(实现)会根据长度进行结束
* 主动调用response.end

通过例子可以知道
包含'Content-Length',会只显示该长度的内容
否则,就需要主动去调用res.end进行结束(语义上属于,Transfer-Encoding:chunked,此处会追加)

来个不规范的栗子,假如

test2
* Content-Length 比内容长
* res.end 就是不调用

用脚丫子也能想到,请求不会中断,必须的啊

如果连接时间特别长,res.write过的数据会咋处理?

test3
用脚丫子也能想到,res.write过的数据会直接丢给请求端(也就是直接显示出来)    
必须的啊,要不然N大的数据存哪(下载)...

chunked,正如最简单的描述,表示无法预知的返回长度,其他表现一毛一样    
Content-Length长度通常是由程序猿/服务器主动去赋值的,故可以经常看到一种蛋疼的现象
有的下载,没有进度条(不返回Content-Length)

正如test3中的展示效果
bigpipe的目的就是请求可以不先结束,但一定得让客户看得见效果

但这个效果要比展示一本小说(test3)要复杂得多,至少他的内容,肯定不会是顺序加载的(要是的话,跟以前有毛区别)

test4
使用script,保证连接过程中的动态变化

非常有意思的使用方式,或许会认为,script应该在请求完成以后在回执行

test5
但其实...遇见</script>的时候就可以开始执行了
